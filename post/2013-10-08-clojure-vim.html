<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>클로저(Clojure)를 위한 Vim 플러그인 | 박연오</title>
  <meta name="description" content="">
  <meta property="og:title" content="클로저(Clojure)를 위한 Vim 플러그인 | 박연오">
  <meta property="og:site_name" content="박연오">
  <meta property="og:author" content="Bak Yeon O (bakyeono@gmail.com)">
  <meta property="og:type" content="article">
  <meta property="og:url" content="/post/2013-10-08-clojure-vim.html">
  <meta property="og:locale" content="ko_KR" />
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="canonical" href="http://bakyeono.net/post/2013-10-08-clojure-vim.html" />
  <link rel="alternate" type="application/rss+xml" title="박연오" href="http://bakyeono.net/feed.xml" />
  <script type="text/javascript" src="/lib/jquery/jquery-1.11.2.min.js"></script>
  <script type="text/javascript">
    "use strict";
    $(document).ready(function () {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create','UA-44446622-4','auto');
      ga('send','pageview');
    });
  </script>
</head>

  <body>
    <header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="/">박연오</a>
    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" />
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" />
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" />
        </svg>
      </a>
      <div class="trigger">
        
      </div>
    </nav>
  </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        
<div class="post">
  <header class="post-header">
    <h1 class="post-title">클로저(Clojure)를 위한 Vim 플러그인</h1>
    <p class="post-meta">
      <span class="post-date">2013-10-08</span>
       • <span class="post-author">박연오(bakyeono@gmail.com)</span>
       • <span class="post-tags">태그: <a class="post-tag" href="/tag/%ED%81%B4%EB%A1%9C%EC%A0%80.html">클로저</a> <a class="post-tag" href="/tag/vim.html">vim</a></span>
    </p>
  </header>
  <article>
    <div class="post-content">
      <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">클로저 코드를 지원하는 편집기</a></li>
  <li><a href="#vimclojurevimclojure-" id="markdown-toc-vimclojurevimclojure-"><a href="http://www.vim.org/scripts/script.php?script_id=2501">VimClojure</a>의 유산</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">설치와 설정</a>    <ul>
      <li><a href="#vim-" id="markdown-toc-vim-">Vim 설치</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">플러그인 설치</a></li>
      <li><a href="#vimrc-" id="markdown-toc-vimrc-">.vimrc 설정</a></li>
    </ul>
  </li>
  <li><a href="#vimvim-fireplace-" id="markdown-toc-vimvim-fireplace-">Vim/vim-fireplace 사용하기</a>    <ul>
      <li><a href="#repl-" id="markdown-toc-repl-">REPL 연동</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">기본 명령</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">단축 명령</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">더 알아보기</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">참고 문서</a></li>
</ul>

<h2 id="section">클로저 코드를 지원하는 편집기</h2>

<p>리스프 코드는 <a href="http://ko.wikipedia.org/wiki/S-%ED%91%9C%ED%98%84%EC%8B%9D">S-표현식</a>을 사용해 문법이 간단하다. 대신 괄호가 많이 사용되기 때문에 괄호 쌍을 정확하게 맞추는 것이 중요하다. 리스프를 처음 접하는 사람은 수많은 괄호들을 복잡하게 느낄 수 있고 괄호를 닫는 위치를 헷갈리거나 괄호 개수를 세다가 질려버릴 수도 있다. 들여쓰기 포맷을 잘 지키고 구문 강조를 지원하는 텍스트 편집기가 있으면 괄호로 인한 실수를 방지할 수 있다. 그래서 리스프 프로그래머에게 구문 강조를 지원하는 편집기는 선택이 아닌 필수다.</p>

<p><a href="http://clojure.org">클로저</a>는 신생 언어여서 클로저 문법을 지원하는 편집기가 많지는 않다. 클로저를 지원하는 편집기로는 <a href="http://www.gnu.org/software/emacs">GNU 이맥스(Emacs)</a>, <a href="http://www.vim.org">Vim</a>과 같은 다목적 텍스트 편집기나 <a href="http://www.eclipse.org">이클립스(Eclipse)</a>같은 IDE 프로그램이 있다.</p>

<ul>
  <li>
    <p>이맥스는 리스프 해커들이 많이 사용하는 편집기로서 아예 이맥스 리스프라는 내장 스크립트 언어로 각종 기능과 플러그인들이 구현되어 있을 정도다. 그래서 리스프 핏줄인 클로저에 대한 지원도 잘 이뤄지고 있다.</p>
  </li>
  <li>
    <p>Vim에서는 리스프 계열 플러그인인 <a href="https://bitbucket.org/kovisoft/slimv">Slimv</a>와 클로저 전용 플러그인인 <a href="http://www.vim.org/scripts/script.php?script_id=2501">VimClojure</a>이 클로저를 지원한다. 그리고 새로 나온 <a href="https://github.com/tpope/vim-fireplace">vim-fireplace</a>와 <a href="https://github.com/guns/vim-clojure-static">vim-clojure-static</a> 조합도 있다.</p>
  </li>
  <li>
    <p>이클립스는 자바 사용자들이 주로 사용하는 IDE인데 클로저와 자바의 가까운 관계 덕분인지 클로저를 위한 플러그인(<a href="https://code.google.com/p/counterclockwise">Counterclockwise</a>)이 있다.</p>
  </li>
</ul>

<p>이 세 가지 개발 환경은 실제로 가장 많이 사용되고 있다. <a href="http://www.clojurebook.com">Clojure Programming</a>의 공동저자인 Chas Emerick의 <a href="http://cemerick.com/2012/08/06/results-of-the-2012-state-of-clojure-survey">2012년 클로저 설문조사</a>에는 “당신이 사용하는 클로저 개발환경은 무엇입니까?” 라는 항목이 있었다. 이에 대한 답변으로</p>

<ul>
  <li>
    <p>이맥스가 58%</p>
  </li>
  <li>
    <p>Vim/VimClojure 조합이 23%</p>
  </li>
  <li>
    <p>이클립스가 18%</p>
  </li>
</ul>

<p>를 차지했다.</p>

<p>과연 리스프 언어답게 이맥스 사용자가 제일 많다. 하지만 나는 이맥스에 잘 적응하지 못했고 펑션 키 조합보다는 ‘vi 키’(hjkl)를 좋아해서 그냥 <a href="http://www.vim.org">Vim</a>을 사용하고 있다. 이 êm의 클로저 지원 플러그인들 가운데 현재 가장 쉽고 유용한 vim-fireplace/vim-clojure-static 조합을 이용해 클로저 코드 편집을 하는 방법을 소개한다.</p>

<p>Vim의 기초 사용법과 플러그인 설치법 정도는 알아야 Vim으로 클로저 코드를 작성할 수 있다. 만일 Vim에 익숙하지 않다면 다음 도서를 추천한다. 둘 다 국내서다. 책값이 부담된다면 도서관에서 잠깐 빌려 봐도 되고 각종 인터넷 문서를 참고해도 된다.</p>

<blockquote>
  <p><strong>내가 추천하는 Vim 입문서</strong></p>

  <p><a href="http://www.insightbook.co.kr/books/programming-insight/%EC%86%90%EC%97%90-%EC%9E%A1%ED%9E%88%EB%8A%94-vim">손에 잡히는 Vim (김선영 지음)</a></p>

  <p><a href="http://www.hanb.co.kr/book/look.html?isbn=978-89-7914-759-9">유닉스 리눅스 프로그래밍 필수 유틸리티 (백창우 지음)</a></p>
</blockquote>

<p>Vim은 유용한 도구이며 폭풍 간지도 자랑하므로 리눅스 사용자라면 기본으로 익혀두는 것이 좋다. 하지만 당장 클로저 사용이 급하고 Vim을 배울 여유가 없다면 쉽게 익힐 수 있는 이클립스를 이용하는 것도 나쁘지 않을 듯하다. 이클립스는 자바에 특화되어 있어 클로저 코드와 자바 코드를 번갈아가며 작성하기에 유용하다는 장점도 있다.</p>

<h2 id="vimclojurevimclojure-"><a href="http://www.vim.org/scripts/script.php?script_id=2501">VimClojure</a>의 유산</h2>

<p>클로저 코드의 편집기에는 크게 두 가지 기능이 있어야 한다.</p>

<p>첫번째는 괄호쌍을 맞춰주고 구문에 색을 입혀 코드 작성을 도와주는 문법 강조 기능이다.</p>

<p>두번째는 편집기에서 입력한 내용을 클로저의 REPL로 보내 실행할 수 있게 하는 REPL 연계 기능이다. 리스프 계열 언어에서 REPL은 함수형 코드 단위들을 바로바로 테스트하며 개발할 수 있게 해주기 때문에 개발 환경의 중요한 구성 요소다. 만일 편집기와 REPL이 연동되지 않으면 일일이 코드를 REPL에 따로 옮겨가며 테스트해야 한다.</p>

<p>Vim을 위한 클로저 플러그인으로 먼저 등장한 VimClojure는 두 기능을 모두 지원한다. 하지만 VimClojure는 REPL 연동시 Nailgun으로 REPL 서버를 구동하도록 하는데 이 설정법이 너무 까다로워서 문제였다. 나도 머리를 싸매고 고생하다 안 돼서 결국 REPL 연동을 포기하고 구문 강조 기능만 이용했었다. 다른 사람들도 어려웠는지, 나중에 Nailgun 설정을 도와주는 vimclojure-easy가 나오기도 했다.</p>

<p>다행히 올해초 VimClojure의 대안으로 vim-fireplace가 나와서 편두통에 시달릴 걱정이 줄어들었다. vim-fireplace를 사용하면 별다른 설정 없이도 <a href="https://github.com/technomancy/leiningen">Leiningen</a>을 통해 실행중인 REPL을 알아서 찾아 연동시켜준다. 다만, vim-fireplace는 구문 강조 기능은 제공하지 않기 때문에 VimClojure의 구문 강조 기능을 사용해야 한다. 이를 위해 VimClojure의 구문 강조 기능만을 따로 뽑아놓은 플러그인이 vim-clojure-static이다.</p>

<p>참고로 VimClojure의 개발자는 VimClojure의 개발 진행속도가 거의 멈춰진 상태고 vim-fireplace가 미래라고 인정했다.(<a href="https://groups.google.com/forum/?fromgroups=#!topic/vimclojure/B-UU8qctd5A">해당 글</a>) 하지만 VimClojure는 REPL 연동만 할 줄 알면 쓸만한 플러그인이고 충분히 개발되어 안정적이기도 하므로 VimClojure를 이미 잘 쓰고 있다면 굳이 vim-fireplace로 갈아탈 필요까지는 없다. VimClojure 개발자가 자기가 만든 프로그램보다 더 나은 프로그램이 나왔다며 추천하는 모습이 존경스럽다.</p>

<h2 id="section-1">설치와 설정</h2>

<p><em>참고: 아래 설치과정은 <a href="http://crunchbang.org">크런치뱅 리눅스 11</a>에서 테스트했다. 다른 리눅스 배포판에서도 크게 다르지 않을 것이다.</em></p>

<h3 id="vim-">Vim 설치</h3>

<p>리눅스에 Vim이 설치되어 있지 않은 경우는 잘 없지만 설치되어 있지 않거나 버전이 낮은 경우에는 알아서 설치하자.</p>

<p>특히, 우분투 계열 배포판인 경우(크런치뱅 포함) Vim-tiny가 설치되어 있으므로 제거하고 Vim을 설치하자.</p>

<pre><code>$ sudo apt-get update
$ sudo apt-get remove vim-tiny
$ sudo apt-get install vim vim-gnome
</code></pre>

<h3 id="section-2">플러그인 설치</h3>

<p>리눅스 배포판 저장소에 없는 프로그램들을 설치하기 위해 curl과 git이 필요하다. 없다면 지금 설치하자.</p>

<pre><code>$ sudo apt-get install curl git
</code></pre>

<p>Vim 플러그인 관리 툴은 여러가지가 있지만 그중 <a href="https://github.com/tpope/vim-pathogen">pathogen.vim</a>이 쉽고 간편하며 vim-fireplace의 제작자가 권장하는 것이기도 하다. 플러그인 설치를 위해 pathogen.vim을 설치하자. 아래의 명령어를 통째로 터미널에 복사하면 된다.</p>

<pre><code># pathogen 공식 페이지에 나와 있는 설치법임
mkdir -p ~/.vim/autoload ~/.vim/bundle; \
curl -Sso ~/.vim/autoload/pathogen.vim \
    https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim
</code></pre>

<p>pathogen을 설치했으면 vim-fireplace를 설치하는 것은 간단하다. 터미널에 아래 명령어를 복사하면 된다.</p>

<pre><code># vim-fireplace 공식 페이지에 나와 있는 설치법임
cd ~/.vim/bundle
git clone git://github.com/tpope/vim-fireplace.git
git clone git://github.com/tpope/vim-classpath.git
git clone git://github.com/guns/vim-clojure-static.git
</code></pre>

<p>pathogen을 이용하므로 ~/.vim/bundle 경로에 플러그인들을 복사해두기만 하면 설치가 끝난다. vim-fireplace와 함께 vim-clojure-static, vim-classpath도 함께 설치했다. vim-clojure-static은 앞에서 설명한 것처럼 VimClojure의 구문 강조 기능을 제공하는 플러그인이고 vim-classpath는 실행 중인 REPL이 없을 때 클로저 코드를 실행하기 위한 JVM의 경로를 지정하는 플러그인이다.</p>

<h3 id="vimrc-">.vimrc 설정</h3>

<p>Vim의 각종 설정과 플러그인 설정은 모두 ~/.vimrc 파일에 기술한다. 좋아하는 편집기로 .vimrc 파일을 편집하자. 파일이 없다면 만들면 된다.</p>

<pre><code>$ vim ~/.vimrc
</code></pre>

<p>설정 파일에 아래 설정 내용 중 필요한 부분을 복사해 넣고 필요한 경우 적절히 수정하기 바란다. 사실 vim-fireplace 플러그인으로 인해 특별히 추가된 것은 거의 없으므로 이미 vimrc 설정을 갖고 있다면 그대로 사용해도 된다.  Vim 왕초보라면 아래 내용을 그대로 복사해 넣자.</p>

<pre><code>" 파일 유형 탐지
filetype plugin on

" 파일 유형별 들여쓰기
filetype indent on

" 리더 키 설정 (각종 플러그인의 단축키 중 &lt;leader&gt;로 표시된 키)
let mapleader = ","
let g:mapleader = ","

" 구문 강조 기능
syntax enable

" 탭 말고 스페이스 사용
set expandtab

" 탭 당 스페이스 수
set shiftwidth=4
set tabstop=4

" 파일을 열었을 때 탭이 있으면 스페이스로 변환
autocmd FileType c retab
autocmd FileType java retab
autocmd FileType lisp retab
autocmd FileType clojure retab

" 행 번호
set number

" pathogen 설정
call pathogen#infect()
call pathogen#helptags()

" vim-clojure-static의 구문 강조 기능이 한번에 처리할 최대 행 수
" 높은 값일수록 긴 함수를 만났을 때 처리시간이 오래 걸린다.
" 0으로 설정하면 제한없이 끝까지 처리.
let g:clojure_maxlines=200
</code></pre>

<h2 id="vimvim-fireplace-">Vim/vim-fireplace 사용하기</h2>

<p>설정을 마쳤으면 Vim에서 클로저 코드를 작성하는 법을 알아보자.</p>

<p>임시 Leiningen 프로젝트를 하나 생성해서 연습해보려 한다. vim-fireplace는 Leiningen 2.0.0 이상 버전과 함께 사용해야 한다. 만일 아직 Leiningen을 설치하지 않았다면 <a href="http://www.bakyeono.net/blog/2013-10-02-clojure-tool-1-leiningen">이 글</a>을 참고해 설치하자.</p>

<p><code>lein new</code> 명령으로 vimtest프로젝트를 생성하자.</p>

<pre><code>$ lein new vimtest
$ cd vimtest
</code></pre>

<h3 id="repl-">REPL 연동</h3>

<p>프로젝트의 디렉토리에서 <code>lein repl</code> 명령으로 REPL을 실행하자. 그러면 아래와 같이 nREPL 서버가 실행되었다는 메시지가 나온다.</p>

<pre><code>$ lein repl
nREPL server started on port 56834 on host 127.0.0.1
REPL-y 0.2.1
Clojure 1.4.0
</code></pre>

<p>REPL이 실행되었으면, REPL을 가만히 둔 채로 다른 터미널에서 vim을 실행하거나 X-window에서 바로 실행할 수 있는 vim-gnome을 실행해 Leiningen이 디폴트로 생성한 파일을 열자.</p>

<pre><code>$ vim src/clojure-with-vim/core.clj
</code></pre>

<p>그러면 vim-fireplace가 자동으로 실행 중인 REPL을 찾아 연동된다. 아래의 명령들을 입력해보면 연동이 된 것을 확인할 수 있을 것이다.</p>

<h3 id="section-3">기본 명령</h3>

<ul>
  <li><strong>:help fireplace</strong> - vim-fireplace의 기능 설명 / 도움말 보기</li>
</ul>

<p>vim-fireplace를 사용하는 방법을 설명한 문서를 보여준다. 어떻게 보면 가장 중요한 명령이다. 그래서 가장 먼저 설명한다. 이 문서에서 설명하지 않은 기능들도 많이 있으니 한 번 확인해보는 것이 좋다.</p>

<ul>
  <li><strong>:Eval</strong> - 표현식 평가</li>
</ul>

<p>core.clj 파일의 아래쪽 적당한 곳에 <code>(println "Hello, clojure with vim!")</code> 을 입력하자. 그리고 입력한 행에 커서가 위치한 상태에서 :Eval 명령을 입력하자.</p>

<pre><code>Hello, clojure with vim!
nil
Press ENTER or type command to continue
</code></pre>

<p>위와 같이 커서가 위치한 행의 내용이 REPL로 전송되어 실행되고, 출력스트림과 반환값이 Vim을 통해 출력된다.</p>

<p>만일 편집기에 입력되어 있지 않은 내용을 평가하고 싶다면 <code>:Eval (do something)</code>과 같은 식으로 :Eval의 인수로 표현식을 넘길 수도 있다.</p>

<ul>
  <li><strong>:Require</strong> - 파일 리로드</li>
</ul>

<p>Vim에서 편집 중인 파일에 <code>(def did-you-read-this? "YES, I did.")</code>를 입력한 후, <code>:update</code> 명령으로 파일을 저장하고, <code>:Require</code> 명령을 실행해 보자.</p>

<p>REPL에서 <code>did-you-read-this?</code> 심볼을 평가하면 파일에 입력한 값이 잘 등록되어 있는 것을 볼 수 있다.</p>

<pre><code>user=&gt; vimtest.core/did-you-read-this?
"YES, I did."
</code></pre>

<p><code>:Require</code> 명령은 REPL에서 <code>(require 패키지명 :reload)</code> 명령을 입력한 것과 같다. 패키지는 현재 편집 중인 파일이다. 파일을 편집한 후 파일 내용을 통째로 REPL로 읽어들이기 위해 사용한다.</p>

<p><code>!</code>를 붙여서 <code>:Require!</code>을 실행하면 <code>(require 패키지명 :reload-all)</code> 명령으로 동작한다. 즉, 현재 파일과 함께 현재 파일이 의존하는 패키지들도 함께 리로드한다.</p>

<ul>
  <li><strong>:Source</strong> - 지정한 대상의 소스 보기</li>
</ul>

<p>:Source 명령을 사용하면 지정한 심볼에 등록된 대상(함수/매크로/상수 등)의 소스코드를 보여준다. <code>(source 대상)</code> 매크로와 같다. 클로저 기본 함수, 사용자가 등록한 값, 라이브러리에 있는 매크로 등 소스코드를 바로 열람할 수 있어 매우 편리하다.</p>

<ul>
  <li><strong>:Doc</strong> - 지정한 대상의 :doc 보기</li>
</ul>

<p>예를 들어, <code>:Doc partition</code>을 입력하면 아래와 같이 partition 함수의 설명이 출력된다.</p>

<pre><code>clojure.core/partition
([n coll] [n step coll] [n step pad coll])
  Returns a lazy sequence of lists of n items each, ...
</code></pre>

<p>:Source와 비슷한 명령이다. 지정한 대상의 :doc 메타데이터(즉, 주석)를 출력한다. <code>(doc 대상)</code> 매크로와 같다.</p>

<ul>
  <li><strong>:FindDoc</strong> - :doc 메타데이터에서 검색</li>
</ul>

<p><code>(find-doc 검색어)</code> 함수와 같다. 검색어로 문자열이나 정규식 리터럴을 넘기면 주석에 검색어가 포함된 심볼들과 문서 내용을 모두 보여준다.</p>

<ul>
  <li><strong>:Apropos</strong> - 심볼 찾기</li>
</ul>

<p><code>(apropos 검색어)</code> 함수와 같다. 검색어로 문자열이나 정규식 리터럴을 넘기면 해당하는 심볼들을 모두 보여준다.</p>

<p>예를 들어, <code>:Apropos part</code>를 입력하면 아래와 같이 “part”로 시작하는 모든 심볼들을 보여준다.</p>

<pre><code>(prtition-by prtition-all partition)
</code></pre>

<p>:Eval과 :Require 두 명령 만으로도 REPL에 편집 내용을 복사하는 번거로움이 확 줄어든다. 그리고 소스코드와 심볼들을 검색할 수 있는 명령어는 클로저 입문자에게든 상급자에게든 매우 유용한 기능이다. 각종 시퀀스 해석 함수가 기억이 안 날 때마다 온라인 레퍼런스 문서만 뒤적이지 말고 클로저와 vim-fireplace가 지원하는 명령들도 활용해 보자.</p>

<ul>
  <li><strong>:A</strong> - 구현 코드/테스트 코드 전환</li>
</ul>

<p>Leiningen은 구현 코드와 단위 테스트 코드를 분리해서 관리하도록 한다. 따라서 src/domain/package.clj 라는 구현 코드 파일이 있으면 이에 대응하는 test/domain/package_test.clj 라는 테스트 코드 파일을 만들어 두고 <code>(clojure.test/run-tests 대상패키지)</code> 명령을 통해 테스트를 수행하도록 할 수 있다.</p>

<p><code>:A</code> 명령을 이용하면 구현 코드와 테스트 코드 두 파일을 서로 전환할 수 있다.</p>

<h3 id="section-4">단축 명령</h3>

<p>vim-fireplace는 좀 더 빠른 손놀림을 위해 단축 명령도 지원한다.</p>

<ul>
  <li><strong>cqc</strong> - REPL 전송용 버퍼 호출</li>
</ul>

<p>Vim 일반 모드에서 <code>cqc</code>를 입력하자. 그러면 편집기 하단에 임시 버퍼가 생성된다. 이곳에 표현식을 입력하면 REPL로 전송되어 평가되며, 평가 결과가 Vim에 출력된다. REPL에 직접 명령을 입력하고자 할 때 사용하면 좋다.</p>

<ul>
  <li><strong>cqq</strong> - REPL 전송용 버퍼 호출 + 현재 행 내용 복사</li>
</ul>

<p><code>cqq</code> 명령은 REPL 전송용 임시 버퍼를 생성하면서 커서가 있는 행의 표현식을 복사해준다. 따라서 파일에 있는 내용을 바로 REPL로 전송해 평가하고 결과를 볼 수 있다.</p>

<ul>
  <li><strong>cpr</strong> - (require 현재문서 :reload)</li>
</ul>

<p>말이 필요없는, 매우 자주 사용되는 현재 문서 리로드 명령. 사용하기 전에 파일을 저장하는 것을 잊지 말자. <code>:Reload</code> 명령과 같은 기능이다.</p>

<ul>
  <li><strong>cpR</strong> - (require 현재문서 :reload-all)</li>
</ul>

<p>의존 패키지들도 수정되어 함께 리로드해야 할 때 사용. <code>:Reload!</code> 명령과 같은 기능이다.</p>

<ul>
  <li><strong>K</strong> - 커서가 위치한 심볼의 :doc 메타데이터 보기</li>
</ul>

<p>:Doc 명령, 또는 (doc 대상) 매크로와 같은 기능이다. <code>Shift</code> + <code>k</code> 키 하나로 해결. (뭐… 가끔 <code>Caps Lock</code>이 눌러진 줄 모르고 커서를 이동하려 할 때 걸리적거리는 단점은 있다.)</p>

<ul>
  <li><strong>[d</strong> - 커서가 위치한 심볼의 소스 보기</li>
</ul>

<p>소스 보기도 키 두번 눌러주는 것으로 해결. 참고로 [는 그냥 <code>[</code> 키를 누르라는 뜻이다.</p>

<ul>
  <li><strong>[Ctrl-d</strong> - 커서가 위치한 심볼이 정의되어 있는 곳으로 이동</li>
</ul>

<p>해당 심볼이 위치한 파일을 찾아 열고 심볼이 정의된 위치로 이동한다. <code>[</code>키와 <code>Ctrl</code> + <code>d</code> 키를 차례로 누르면 된다.</p>

<ul>
  <li><strong>gf</strong> - 커서가 가리키는 파일로 이동</li>
</ul>

<p>주로 의존 패키지로 이동할 때 사용한다.</p>

<ul>
  <li>
    <p><strong>cmm</strong> - 현재 행을 <code>macroexpand</code> 한 결과 보기</p>
  </li>
  <li>
    <p><strong>c1m</strong> - 현재 행을 <code>macroexpand-1</code> 한 결과 보기</p>
  </li>
</ul>

<p>이상으로 vim-fireplace가 지원하는 명령들을 간단히 살펴보았다. 더 자세한 내용은 <code>:help fireplace</code>를 통해 확인해보기 바란다.</p>

<h2 id="section-5">더 알아보기</h2>

<p>이 문서에서 다루지는 않았지만 Vim에서 클로저 코드 편집을 도와주는 플러그인들이 몇가지 더 있다. vim-fireplace와 함께 사용하면 유용한 플러그인들을 간단하게만 소개한다.</p>

<ul>
  <li><a href="https://github.com/kien/rainbow_parentheses.vim">rainbow_parentheses.vim</a>: 무지개 괄호. 즉 괄호들의 색상을 계층적으로 달리하여 표시하도록 해 준다. Slimv와 VimClojure는 무지개 괄호를 기본으로 지원하는데 vim-clojure-static에서는 이 기능을 빼 놓았다. 그래서 알록달록한 무지개 괄호를 보고 싶다면 이 플러그인을 사용하면 된다. (내 생각에 그다지 가독성을 높여주지는 않는 것 같다. 하지만 예뻐서 쓴다.)</li>
</ul>

<p>아래 스크린샷은 무지개 괄호를 사용하고 있는 나의 클로저 편집 환경이다.</p>

<p><img src="http://bakyeono.net/img/my-vim-clojure-1.png" alt="무지개 괄호를 사용하고 있는 나의 클로저 편집 환경" /></p>

<ul>
  <li><a href="http://www.vim.org/scripts/script.php?script_id=3998">paredit.vim</a>: 이맥스의 ParEdit Mode를 Vim 용으로 구현한 것이다. 좋아하는 사람도 있고 싫어하는 사람도 있는데, 사람들이 이 모드를 싫어하는 이유는 사용법을 모르면 코드 작성에 몹시 방해가 되고 거슬리기 때문이며 때때로 오류가 발생해 괄호 처리가 제대로 되지 않는 때도 있기 때문이다.</li>
</ul>

<p>하지만 약간 시간을 투자해서 배워두면 자동 괄호 완성 기능과 문맥별 편집 기능 덕분에 타자량을 상당히 줄일 수 있다. 1~2시간 정도 투자해서 배워볼 마음만 있다면 꼭 배워서 써보라고 권하고 싶다. 한가지 팁을 알려주자면, 편집 중인 코드를 주석처리하면 해당 부분에 한해 paredit의 간섭을 받지 않고 자유롭게 편집할 수 있다. 편집을 마친 후 주석을 해제하면 된다.</p>

<ul>
  <li><a href="https://github.com/guns/vim-sexp">vim-sexp</a>: vim-fireplace의 제작자가 개발하고 있는 또 다른 플러그인으로, vim의 편집 방법을 리스프에 도입한다고 한다. 나는 아직 써보지 않았지만 개발이 완료되면 유용할 것 같아 일단 링크해 둔다.</li>
</ul>

<h2 id="section-6">참고 문서</h2>

<ul>
  <li><a href="https://github.com/tpope/vim-fireplace">vim-fireplace GitHub 페이지</a></li>
  <li><a href="https://github.com/tpope/vim-pathogen">pathogen.vim GitHub 페이지</a></li>
</ul>


    </div>
  </article>
</div>

      </div>
    </div>
    <footer class="site-footer">
  <div class="wrapper">
    <h2 class="footer-heading">박연오</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:bakyeono@gmail.com">bakyeono@gmail.com</a></li>
          <li><p class="rss-subscribe"><a href="http://feeds.feedburner.com/bakyeono">RSS 구독</a></p></li>
        </ul>
      </div>
      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/bakyeono">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>
              <span class="username">bakyeono</span>
            </a>
          </li>
          
          
        </ul>
      </div>
      <div class="footer-col  footer-col-3">
        <p class="text">Workers of the world, unite!</p>
      </div>
    </div>
    <div class="copyright">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />
      This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.<br />
      Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="http://bakyeono.net" rel="dct:source">http://bakyeono.net</a>.
    </div>
  </div>
</footer>

  </body>
</html>
