---
layout: book
book: 파이썬 프로그래밍 입문서
title: 4.2 수
comments: true
permalink: /python-programming/chapter-4-2.html
---
* table of contents
{:toc}

컴퓨터 프로그래밍에서 수는 한 가지가 아니다. 수학 시간에 배운 것처럼 수의 집합은 자연수, 정수, 실수, 복소수 등으로 구별할 수 있다. 문맥 없는 비트 묶음만으로는 자연수밖에 표현하지 못한다. 비트로 정수, 실수, 복소수 등을 나타내려면 약속이 필요하므로, 수의 종류에 따라 데이터 유형도 여러 가지가 있다. 파이썬은 수를 나타내는 데이터 유형으로 정수, 실수, 복소수를 제공한다.


### 4.2.1 정수

**정수(integer, 줄여서 int)**는 자연수에 음양 부호(+, -)가 붙은 것이다. 비트 묶음을 이용하면 어떤 크기의 자연수라도 표현할 수 있고, 부호를 표현하는 데는 비트 하나면 충분하다. 그러므로 정수는 컴퓨터가 다루기에 가장 쉬운 수다. 파이썬에서도 정수는 수를 나타내는 가장 기본적인 데이터 유형이다. 파이썬에 자연수 유형은 존재하지 않으므로 자연수를 다룰 때는 정수로 대신하면 된다.

그동안 정수를 여러 번 사용해 보았다. 파이썬에서 소수점 없이 입력된 수, 즉 ``1024``, ``0``, ``-15`` 같은 표현은 모두 정수다. 다음은 IDLE 대화식 쉘에 정수를 입력해 본 것이다.

    >>> 1000  # 양의 정수
    1000
    >>> -100000000000000000000  # 매우 크거나 매우 작은 정수도 문제 없다
    -100000000000000000000

**코드 4-1** 정수의 예

일상 생활에서는 ``1,234,567,890``과 같이 큰 수를 표현할 때 콤마를 사용하는데, 파이썬에서는 이렇게 하면 안 된다. 이것은 정수가 아니라 나중에 배울 튜플이라는 표현이다. 큰 수를 표현할 때는 그냥 ``1234567890``처럼 콤마 없이 표현하면 된다. 수가 너무 커서 콤마를 꼭 붙이고 싶다면 수 뒤에 주석으로 표기해 두자.


**참고** 다른 프로그래밍 언어의 정수 유형

다른 프로그래밍 언어(C가 대표적이다) 중에는 정수를 나타내는 데이터 유형을 수의 표현범위에 따라 여러 가지로 구분하는 것도 있다. 하지만 파이썬에서는 정수를 나타내는 데이터 유형이 정수 하나 뿐이고 다룰 수 있는 수의 범위도 무제한이다. 초보 프로그래머에게는 파이썬의 방식이 더 직관적이다.


#### 팔진법과 십육진법

정수는 팔진법이나 십육진법으로도 표현할 수 있다. ``0o77``처럼 ``0o``로 시작하는 수는 팔진수, ``0xff``와 같이 ``0x``로 시작하는 수는 십육진수다. 코드 4-2의 예를 보자.

    >>> 0o77  # 팔진수 77
    63
    >>> 0xff  # 십육진수 ff
    255
    >>> 255 == 0xff  # 진법이 달라도 같은 정수다
    True

**코드 4-2** 팔진법과 십육진법으로 정수 표현하기

컴퓨터 내부에서는 모든 수를 이진법으로 다룬다. 따라서 코드에서 어떤 진법으로 수를 표기하든 컴퓨터에게는 차이가 없다. 그렇다면 왜 다양한 진법 표기를 지원할까? 팔진법 표기법과 십육진법 표기법은 사람이 보기에 편리할 때를 위한 것이다. 물론 일반적인 상황에서 사람은 십진법이 가장 편할 것이다. 십육진법은 간혹 쓸 일이 있지만, 팔진법은 쓸 일도 거의 없고 사용하지 않는 편이 좋다. "팔진법과 십육진법이 이런 거구나" 하고 읽을 줄만 알면 된다.


### 4.2.2 실수

실수(real number)는 ``-1.0``, ``3.1415``처럼 소수점 아래까지 표현되는 수다. ``1.0``은 유형이 실수인 데이터이므로 정수 데이터인 ``1``과는 구별된다. 앞에서 많이 사용해 온 표현이므로 이미 익숙할 것이다.

    >>> 3.1415
    3.1415

**코드 4-3** 실수의 표현

파이썬에서 실수를 나타내는 데이터 유형은 **부동소수점 수(floating point number, 줄여서 float)**다. 이 이름을 풀어 설명하면 움직이는 소수점이 붙은 수라는 뜻이다. 실수 유형에 이런 이름이 붙은 이유는 곧이어 설명한다. 이 책에서는 편의상 부동소수점 수를 실수라고도 부를 것이다.


#### 과학 표기법

부동소수점 수는 수의 과학 표기법과 연관이 있다. 과학 표기법이란 매우 작은 수와 매우 큰 수를 다루는 일이 많은 과학 분야에서 수를 표기하는 방법이다. 전자계산기로 장난을 치다 보면 숫자가 너무 커져서 화면에 '1.234e5' 같은 수가 출력되는 것을 볼 수 있다. 전자계산기의 '1.234e5' 처럼 수의 중간에 'e'를 붙여 표현하는 방법이 과학 표기법이다.

과학 표기법은 수를 가수와 지수로 나누어 표기한다. 1.234e5에서 e를 중심으로 앞의 수(1.234)는 가수, 뒤의 수(5)는 지수다. 이 수의 값은 가수의 소수점 위치를 지수만큼 오른쪽으로 옮기면 구할 수 있다. 1.234의 소수점을 다섯 칸 오른쪽으로 옮기면 123400.0이 된다. 이 방법을 이용하면 매우 큰 수나 매우 작은 수를 간결하게 표기할 수 있어 편리하다.

파이썬에서도 과학 표기법으로 실수를 나타낼 수 있다. ``e``를 구분자로 하여 ``가수e지수``로 표기하면 된다. IDLE 대화식 쉘에 코드 4-4를 따라 입력해 보면 어렵지 않게 이해할 수 있을 것이다.

    >>> 1.23e0   # 1.23 * 10 ^ 0
    1.23
    >>> 1.23e6   # 1.23 * 10 ^ 6
    1230000.0
    >>> 1.23e-4  # 1.23 * 10 ^ -4
    0.000123

**코드 4-4** 과학 표기법으로 실수 표기

프로그램에 과학 표기법으로 수를 표기할 일이 많지는 않다. 하지만 연산 결과가 크거나 작을 때 과학 표기법으로 출력되는 경우가 종종 있으므로 눈에 익혀두는 것이 좋다.

실수를 가수와 지수를 나누어 표현하는 방식은 컴퓨터 내부에서 실수를 비트로 다루는 데도 활용된다. 컴퓨터는 실수를 표현할 때 실수 전체를 비트에 나열하는 것이 아니라, 부호, 지수, 가수로 나누어 각각 비트 묶음에 담는다. 가수를 지수만큼 소수점 이동시킨 수가 실제 값이다. 소수점의 위치가 움직이는 수라는 뜻의 '부동소수점 수'라는 이름도 이 방법에서 유래한 것이다.  


#### 실수의 정밀도 문제

수학의 세계에서는 정수가 실수에 포함되지만, 대부분의 프로그래밍 언어에서는 정수와 실수를 서로 다른 유형으로 구별한다. 정수도 실수로 통일해서 취급하면 편리할텐데(그렇게 하는 프로그래밍 언어도 있다) 왜 구별하는 것일까? 주된 이유는 비트로 정수와 실수를 표현하는 방법이 다르기 때문이다.

정수는 비트를 이용해 정확하게 표현할 수 있다. 하지만 실수는 비트로 정확하게 표현하지 못한다. 이진법에서는 딱 나누어 떨어지는 소수가 별로 없기 때문이다. 0.1이라는 간단한 수조차도 나누어 떨어지지 않는다. (1을 2로 여러 번 나누어서 0.1을 만들려면 몇 번 나누어야 하는지 계산해 보라.) 이런 수는 이진수로는 순환소수가 되며, 비트로 정확하게 표현할 수 없으므로 아무리 정밀하게 표현하려 해도 오차가 있을 수밖에 없다. 코드 4-5는 이 문제를 대화식 쉘에서 확인해 본 것이다.

    >>> 0.1               # 파이썬이 0.1을 제대로 출력하는 것처럼 보이지만...
    0.1
    >>> 1.1 - 1.0         # 실수 연산에는 세밀한 오차가 있다
    0.10000000000000009

**코드 4-5** 파이썬의 실수 오차

코드 4-5처럼 ``0.1``을 바로 입력해 보면 파이썬이 0.1을 그대로 0.1로 평가해 오차없이 출력하는 것처럼 보인다. 실제로는 오차가 있지만 0.1이 출력된 이유는 파이썬이 실수를 출력할 때 사용자의 편의를 위해 무의미하다고 판단되는 작은 오차를 반올림해서 출력해주기 때문이다.

소수를 연산한 결과를 확인하면 자동 반올림 기능을 피해서 실제 값을 확인할 수 있다. 코드 4-5의 ``1.1 - 1.0``을 계산해 보면 계산 결과가 ``0.1``이 아니라 ``0.10000000000000009``로 나온다. (이것도 어느 수준에서 반올림된 것으로, 컴퓨터에 실제 저장된 값은 더 세밀하다.) 매우 미미한 오차이지만 어쨌든 정확하지는 않은 것이다.

실수를 표현하는 데 사용되는 비트의 양을 늘릴 수록 오차의 크기는 작아진다. 하지만 용량을 아무리 늘려도 오차가 완전히 없어지지는 않는다. 무한히 반복되는 순환소수를 종이에 정확하게 적으려면 무한한 크기의 종이에 무한히 적어야 하는 것이다. 컴퓨터의 자원은 유한하기 때문에 실수를 아무리 정밀하게 표현하려 해도 근사치를 사용할 수밖에 없다.

컴퓨터가 정확한 기계라는 생각은 실수의 세계에서는 옳지 않다. 그래도 오차는 미미하므로 일반적인 상황에서는 큰 문제가 되지 않는다. 주로 신경써야 할 문제는 ``1.1 - 1.0 == 0.1``처럼 실수를 동등 연산자로 비교하지 말아야 한다는 것이다. ``0.00009 < 1.1 - 1.0 < 0.100001`` 처럼 일정한 오차범위를 정해서 비교하는 것이 더 적절하다.

정수와 실수는 각자의 특징과 한계가 있기 때문에 대부분의 프로그래밍 언어에서 서로 다른 유형으로 구별되어 있다. 처리하려는 데이터에 올바른 유형이 정수인지 실수인지 잘 파악해야 한다.


#### 무한대

실수 데이터 중에는 양의 무한대와 음의 무한대가 있다. (정수 유형에는 없다.) 양의 무한대와 음의 무한대를 나타내는 데이터는 각각 ``float('inf')``와 ``float('-inf')``라는 표현을 이용해 만든다.

    >>> float('inf')          # 양의 무한대
    inf
    >>> float('-inf')         # 음의 무한대
    -inf
    >>> 1e100 < float('inf')  # 무한대는 다른 모든 실수보다 크다
    True
    >>> 1e309                 # 너무 큰 실수는 무한대로 평가된다
    inf
    >>> 1e-324                # 너무 0에 가까운 실수는 0으로 평가된다
    0.0

**코드 4-6** 무한대

정밀도 문제와 비슷하게 실수를 나타내는 데 필요한 용량이 제한되어 있으므로, 너무 큰 실수는 무한대로 평가되어 버리고 너무 0에 가까운 수(무한소)는 0으로 평가되어 버린다. 일반적인 프로그래밍 상황에서 이런 수를 취급할 일은 거의 없다고 봐도 무방하다.


### 4.2.3 복소수

파이썬의 수치 데이터 유형에는 앞에서 설명한 정수와 부동소수점 수 외에 **복소수(complex number, 줄여서 complex)**가 있다. 복소수는 고등학교 수학에서 등장한다. 아직 복소수를 배우지 않았다면 이 절의 내용은 생략할 수 있다. 수학 전공자가 아니라면 복소수를 프로그래밍해야 하는 상황은 드물다.

수학의 표기법에서 복소수는 '1+2i'와 같이 실수부와 허수부를 나누어 표기한다. 이 때 'i'는 제곱해서 -1이 되는 가상의 상수이며 복소수의 허수부를 나타내기 위한 기호로 사용된다.

파이썬에서 복소수를 표현할 때는 ``1+2j`` 처럼 i만 j로 바꾸어 표기하면 된다.

    >>> 1-2j         # 실수부가 1, 허수부가 -2인 복소수
    (1-2j)
    >>> (1-2j).real  # 복소수의 실수부
    1.0
    >>> (1-2j).imag  # 복소수의 허수부
    -2.0

**코드 4-7** 복소수의 표현과 연산

복소수에 ``.real``을 계산하면 실수부를, ``.imag``를 계산하면 허수부를 구할 수 있다. 단, 소수점과 구별하기 위해 수를 괄호로 감싸주어야 한다.

1을 실수 유형으로 나타낼 때 ``1.0`` 처럼 소수점 `.0`을 붙여야 하는 것처럼, 1을 복소수 유형으로 나타낼 때는 ``1+0j`` 처럼 ``+0j``를 붙여주면 된다.


### 4.2.4 수의 연산

이 장의 초반부에서 데이터의 유형에 따라 적용할 수 있는 연산이 다르다는 점을 언급했다. 그 말대로라면 정수, 실수, 복소수는 서로 다른 유형이기 때문에 적용할 수 있는 연산이 달라야 할 것이다. 하지만 이들은 넓은 의미에서는 모두 수라는 공통점이 있기 때문에 동일한 연산이 적용된다.

수로 할 수 있는 연산은 대부분 **2장 수와 연산**에서 살펴보았다. 기억을 되살려 보자면, 수에는 사칙연산, 거듭제곱, 몫과 나머지 계산, 반올림 계산, 절대값 계산 등이 가능하다. 그리고 방금 앞에서 배운 복소수의 실수부와 허수부를 구하는 연산도 있다. 이 연산들은 정수, 실수, 복소수에 가리지 않고 모두 공통적으로 사용 가능하다. 심지어 정수를 반올림하거나 정수의 실수부를 구하는 것도 할 수 있다. 다음 예제를 보자.

    >>> round(10)  # 실수와 마찬가지로 정수도 반올림이 된다
    10 
    >>> (10).real  # 정수에서 복소수의 실수부를 구하는 연산도 가능하다
    10

**코드 4-8** 수 유형을 위한 연산은 통용된다

정수를 반올림하거나 정수의 실수부를 구하는 연산은 쓸모없어 보일 수 있다. 하지만 정수는 실수에 포함되고 실수는 복소수에 포함되므로 수를 위한 연산이 공통적으로 가능한 것은 논리적으로 타당하다. 어떤 변수에 저장된 수가 정수인지 실수인지 복소수인지 모른 채 연산을 해야 한다면 이런 특성이 유용할 것이다.

비슷한 특징으로, 정수와 실수를 더하거나 실수와 복소수를 곱하는 등 서로 다른 유형의 수를 함께 계산하는 것도 가능하다. 이 때 연산 결과는 더 넓은 범위의 수 유형으로 계산된다. 정수와 실수를 계산하면 실수가 되고, 실수와 복소수를 계산하면 복소수가 된다.

    >>> 10 + 0.5    # 정수와 실수의 연산 -> 실수
    10.5
    >>> 0.5 * 1+2j  # 실수와 복소수의 연산 -> 복소수
    (0.5+2j)

**코드 4-9** 서로 다른 유형의 수를 함께 계산해도 된다

그렇다면 수 데이터에 적용할 수 없는 연산에는 무엇이 있을까? 아직 소개한 적은 없지만 곧 배우게 될 텍스트 데이터의 대문자 변경 연산(`upper()`)을 수에 적용해 보자.

    >>> (10).upper()  # 텍스트를 위한 연산은 오류를 발생시킨다
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: 'int' object has no attribute 'upper'

**코드 4-10** 수에 적용할 수 없는 연산의 예

`(10).upper()`는 ``10``이라는 수를 대문자로 변경시키는 연산이다. 수를 대문자로 바꾼다는 것은 논리적으로도 말이 안 되지만, 수 데이터 유형에서 지원하지 않는 연산이다. 그래서 오류가 발생한다.


#### 연습문제

**연습문제 4-1** 팔진법과 십육진법

프로그래머 세 사람이 자신의 나이를 말하고 있다.

프로그래머 A: "저는 0x7d0"년에 태어났습니다. 올해로 0x12살이 되었네요."
프로그래머 B: "그러시군요. 저는 올해 0o22세입니다."
프로그래머 C: "저는 18살입니다."

세 사람의 출생년은 각각 언제인가?

힌트: IDLE의 대화식 쉘에 팔진수 또는 십육진수를 입력하면 십진수로 출력된다.

이 문제를 풀면서 프로그램을 작성할 때 팔진법과 십육진법을 가급적 사용하지 않는 편이 좋은 이유는 무엇인지 생각해 보자.


**연습문제 4-2** 과학 표기법

-252.87을 과학 표기법으로 나타내 보아라.


**연습문제 4-3** 거의 같은 수

두 실수가 거의 같은지 검사하는 함수 ``almost_equal()``를 정의하라. 이 함수는 실수 두 개를 입력받아 두 실수의 차이(오차허용범위)가 0.0001 미만이면 True를 그렇지 않으면 False를 반환한다. 또, 할 수 있다면 오차허용범위를 함수를 호출할 때 지정하는 것도 가능하도록 정의해 보아라.

